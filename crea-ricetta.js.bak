#!/usr/bin/env node

/**
 * CREA RICETTA ‚Äî CLI Entry Point
 *
 * Uso:
 *   node crea-ricetta.js --url "https://giallozafferano.it/ricetta/Focaccia.html"
 *   node crea-ricetta.js --nome "Focaccia Barese" --idratazione 80
 *   node crea-ricetta.js --nome "Pizza Napoletana" --tipo "Pizza" --note "cottura in forno casalingo"
 *   node crea-ricetta.js --scopri "focaccia pugliese"         ‚Üê cerca e genera!
 *   node crea-ricetta.js --scopri "pane rustico" --quante 3   ‚Üê cerca 3 risultati
 *   node crea-ricetta.js --valida                             ‚Üê valida TUTTE le ricette!
 *
 * Il flusso automatizzato:
 *   1. [--scopri] Cerca ricette su SerpAPI
 *   2. Scraping dati dalla URL (o generazione da zero)
 *   3. Riscrittura AI con Claude Sonnet (stile tecnico Ricettario)
 *   4. [VALIDAZIONE] Cross-check con fonti reali
 *   5. Generazione HTML completo (identico al template)
 *   6. Salvataggio in ricette/{categoria}/slug.html
 *   7. Inserimento automatico della card nella homepage
 */

import 'dotenv/config';
import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { resolve } from 'path';
import { scrapeRecipe } from './src/scraper.js';
import { enhanceRecipe, generateRecipe } from './src/enhancer.js';
import { generateHtml } from './src/template.js';
import { injectCard } from './src/injector.js';
import { discoverRecipes, askUser } from './src/discovery.js';
import { validateRecipe, validateAllRecipes } from './src/validator.js';
import { verifyRecipe, verifyAllRecipes, transcribePhilipsPdf } from './src/verify.js';
import { findAndDownloadImage } from './src/image-finder.js';

// ‚îÄ‚îÄ Parse CLI args ‚îÄ‚îÄ
function parseArgs() {
    const args = process.argv.slice(2);
    const parsed = {};
    for (let i = 0; i < args.length; i++) {
        if (args[i].startsWith('--')) {
            const key = args[i].replace('--', '');
            parsed[key] = args[i + 1] || true;
            i++;
        }
    }
    return parsed;
}

// ‚îÄ‚îÄ Main ‚îÄ‚îÄ
async function main() {
    const args = parseArgs();

    console.log('\nüî• ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('   RICETTARIO TOOLS ‚Äî Recipe Generator');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

    if (!args.url && !args.nome && !args.scopri && !args.valida && !args.verifica && !args['verifica-ricetta'] && !args['trascrivi-philips'] && !args['trascrivi-immagini'] && !args['aggiorna-immagini']) {
        console.log(`Uso:
  node crea-ricetta.js --url "https://sito.com/ricetta"
  node crea-ricetta.js --nome "Focaccia Barese" [--idratazione 80] [--tipo Pizza] [--note "..."]
  node crea-ricetta.js --scopri "focaccia pugliese" [--quante 5]
   node crea-ricetta.js --valida                                    ‚Üê valida tutte le ricette
   node crea-ricetta.js --verifica                                   ‚Üê verifica qualit√† con Claude AI
   node crea-ricetta.js --verifica-ricetta "path/to/ricetta.html"    ‚Üê verifica singola ricetta
   node crea-ricetta.js --trascrivi-philips                          ‚Üê trascrivi vecchi PDF Philips 7000
   node crea-ricetta.js --trascrivi-immagini                         ‚Üê trascrivi immagini PNG in HTML
   node crea-ricetta.js --aggiorna-immagini                         ‚Üê scarica immagini Wikimedia

Opzioni:
  --url                 URL della ricetta da scrappare e migliorare
  --nome                Nome ricetta da generare da zero con AI
  --scopri              Cerca ricette su Google e scegli quale generare
   --valida              Valida le ricette con fonti reali (cross-check)
   --verifica            Verifica qualit√† ricette con Claude AI (dosi, temp, glossario)
   --verifica-ricetta    Verifica singola ricetta (path al file HTML)
   --trascrivi-philips   Trascrivi ricette da PDF Philips Serie 7000
   --aggiorna-immagini   Scarica immagini da Wikimedia Commons per tutte le ricette
  --quante              Numero di risultati da mostrare (default: 5, max: 10)
  --idratazione         Idratazione target in % (opzionale)
  --tipo                Categoria: Pane, Pizza, Pasta, Lievitati (opzionale)
  --note                Note aggiuntive per Claude (opzionale)
  --output              Percorso output personalizzato (opzionale)
  --no-inject           Non inserire la card nella homepage (opzionale)
  --no-image            Salta la ricerca immagini Wikimedia (opzionale)
  --no-valida           Salta la validazione post-generazione (opzionale)
`);
        process.exit(0);
    }

    // ‚îÄ‚îÄ Mode E: Aggiorna immagini da Wikimedia ‚îÄ‚îÄ
    if (args['aggiorna-immagini']) {
        const ricettarioPath = resolve(process.cwd(), args.output || process.env.RICETTARIO_PATH || '../Ricettario');
        console.log('üì∏ AGGIORNAMENTO IMMAGINI ‚Äî Wikimedia Commons\n');

        const { readdirSync, readFileSync: readFS } = await import('fs');
        const recipeDirs = ['pane', 'pizza', 'pasta', 'lievitati', 'focaccia'];
        const results = [];
        const usedUrls = new Set(); // Track immagini gi√† scaricate per evitare duplicati

        for (const dir of recipeDirs) {
            const dirPath = resolve(ricettarioPath, 'ricette', dir);
            let files;
            try { files = readdirSync(dirPath).filter(f => f.endsWith('.html')); }
            catch { continue; }

            for (const file of files) {
                const filePath = resolve(dirPath, file);
                const html = readFS(filePath, 'utf-8');

                const titleMatch = html.match(/<title>([^<]+?)\s*[‚Äî‚Äì-]/);
                const recipeName = titleMatch?.[1]?.trim() || file.replace('.html', '').replace(/-/g, ' ');
                const category = dir.charAt(0).toUpperCase() + dir.slice(1);

                console.log(`\n${'‚îÄ'.repeat(50)}`);
                console.log(`üìã ${recipeName} (${category})`);
                console.log(`${'‚îÄ'.repeat(50)}`);

                const imageData = await findAndDownloadImage(
                    { title: recipeName, category, slug: file.replace('.html', ''), imageKeywords: [] },
                    ricettarioPath,
                    usedUrls
                );

                results.push({
                    name: recipeName,
                    category,
                    found: !!imageData,
                    image: imageData?.homeRelativePath || null,
                });

                await new Promise(r => setTimeout(r, 2000));
            }
        }

        console.log('\n' + '‚ïê'.repeat(60));
        console.log('   üìä RIEPILOGO IMMAGINI');
        console.log('‚ïê'.repeat(60) + '\n');
        for (const r of results) {
            const emoji = r.found ? 'üü¢' : 'üî¥';
            console.log(`  ${emoji} ${r.name} ‚Üí ${r.image || 'nessuna immagine'}`);
        }
        const found = results.filter(r => r.found).length;
        console.log(`\n  üìà ${found}/${results.length} immagini scaricate`);
        console.log(`  üìÅ Salvate in: images/ricette/\n`);

        process.exit(0);
    }

    // Verifica API key
    if (!process.env.ANTHROPIC_API_KEY) {
        console.error('‚ùå ANTHROPIC_API_KEY non trovata. Copia .env.example in .env e inserisci la tua chiave.');
        process.exit(1);
    }

    // ‚îÄ‚îÄ Mode D: Validazione ricette (SerpAPI) ‚îÄ‚îÄ
    if (args.valida) {
        const ricettarioPath = resolve(process.cwd(), args.output || process.env.RICETTARIO_PATH || '../Ricettario');
        console.log('üî¨ VALIDAZIONE PRO ‚Äî Cross-check con fonti reali\n');

        const results = await validateAllRecipes(ricettarioPath);

        // Riepilogo finale
        console.log('\n' + '‚ïê'.repeat(60));
        console.log('   üìä RIEPILOGO VALIDAZIONE');
        console.log('‚ïê'.repeat(60) + '\n');

        const sorted = results.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));
        for (const r of sorted) {
            const emoji = r.confidence >= 75 ? 'üü¢' : r.confidence >= 50 ? 'üü°' : 'üî¥';
            console.log(`  ${emoji} ${r.confidence}% ‚Äî ${r.title}`);
        }

        const avgConfidence = Math.round(
            sorted.filter(r => r.confidence >= 0).reduce((sum, r) => sum + r.confidence, 0) /
            sorted.filter(r => r.confidence >= 0).length
        );
        console.log(`\n  üìà Media confidenza: ${avgConfidence}%`);
        console.log(`  üìÑ Report salvati come .validazione.md accanto a ogni ricetta\n`);

        process.exit(0);
    }

    // ‚îÄ‚îÄ Mode D2: Verifica qualit√† con Claude AI ‚îÄ‚îÄ
    if (args.verifica || args['verifica-ricetta']) {
        const ricettarioPath = resolve(process.cwd(), args.output || process.env.RICETTARIO_PATH || '../Ricettario');
        console.log('üß† VERIFICA QUALIT√Ä ‚Äî Claude AI\n');

        if (args['verifica-ricetta']) {
            // Singola ricetta
            const filePath = resolve(process.cwd(), args['verifica-ricetta']);
            const { recipe, result } = await verifyRecipe(filePath);
            const emoji = result.score >= 80 ? 'üü¢' : result.score >= 60 ? 'üü°' : 'üî¥';
            console.log(`\n${emoji} ${result.score}/100 ‚Äî ${result.verdict}`);
            console.log(`\n${result.summary}`);
            if (result.issues?.length > 0) {
                console.log('\nProblemi:');
                result.issues.forEach(i => console.log(`  ${i.severity} ${i.area}: ${i.message}`));
            }
            if (result.glossary?.length > 0) {
                console.log('\nüìñ Glossario:');
                result.glossary.forEach(g => console.log(`  ‚Ä¢ ${g.term}: ${g.definition}`));
            }
        } else {
            // Tutte le ricette
            const results = await verifyAllRecipes(ricettarioPath, { force: !!args.forza });

            console.log('\n' + '‚ïê'.repeat(60));
            console.log('   üìä RIEPILOGO VERIFICA QUALIT√Ä');
            console.log('‚ïê'.repeat(60) + '\n');

            const sorted = results.filter(r => r.score >= 0).sort((a, b) => b.score - a.score);
            for (const r of sorted) {
                const emoji = r.score >= 80 ? 'üü¢' : r.score >= 60 ? 'üü°' : 'üî¥';
                const flags = [
                    r.needsSetupFix ? '‚ö†Ô∏èSetup' : '',
                    r.needsBaking ? 'üî•Cottura' : '',
                    r.glossaryTerms > 0 ? `üìñ${r.glossaryTerms}` : '',
                ].filter(Boolean).join(' ');
                console.log(`  ${emoji} ${r.score}/100 ‚Äî ${r.title} ${flags}`);
            }

            const avg = Math.round(sorted.reduce((s, r) => s + r.score, 0) / sorted.length);
            console.log(`\n  üìà Media: ${avg}/100`);
            console.log(`  üìÑ Report salvati come .verifica.md\n`);
        }

        process.exit(0);
    }

    // ‚îÄ‚îÄ Mode D3: Trascrivi PDF Philips ‚îÄ‚îÄ
    if (args['trascrivi-philips']) {
        const ricettarioPath = resolve(process.cwd(), args.output || process.env.RICETTARIO_PATH || '../Ricettario');
        const pdfDir = resolve(ricettarioPath, 'public', 'pdf');
        console.log('üìÑ TRASCRIZIONE PDF ‚Äî Philips Serie 7000\n');

        const { readdirSync: readDir } = await import('fs');
        const pdfs = readDir(pdfDir).filter(f => f.toLowerCase().endsWith('.pdf'));

        const allRecipes = [];
        for (const pdf of pdfs) {
            try {
                const result = await transcribePhilipsPdf(resolve(pdfDir, pdf));
                console.log(`\n‚úÖ ${pdf}: ${result.recipes?.length || 0} ricette trovate`);
                if (result.recipes) allRecipes.push(...result.recipes);
            } catch (err) {
                console.error(`‚ùå ${pdf}: ${err.message}`);
            }
        }

        // Salva risultato
        const { mkdirSync: mkDir, existsSync: exists } = await import('fs');
        const dataDir = resolve(process.cwd(), 'data');
        if (!exists(dataDir)) mkDir(dataDir, { recursive: true });

        const outputPath = resolve(dataDir, 'philips-recipes.json');
        const { writeFileSync: writeFS } = await import('fs');
        writeFS(outputPath, JSON.stringify({ machine: 'Philips Serie 7000', recipes: allRecipes }, null, 2), 'utf-8');
        console.log(`\nüìÅ Salvate ${allRecipes.length} ricette in: ${outputPath}\n`);

        process.exit(0);
    }

    // ‚îÄ‚îÄ Mode D4: Trascrivi Immagini Philips -> HTML ‚îÄ‚îÄ
    if (args['trascrivi-immagini']) {
        const ricettarioPath = resolve(process.cwd(), args.output || process.env.RICETTARIO_PATH || '../Ricettario');
        const pdfDirs = [
            resolve(ricettarioPath, 'public', 'pdf', 'Philips Pasta maker'),
            resolve(ricettarioPath, 'public', 'pdf', 'Philips Pasta maker_')
        ];
        console.log('üì∏ TRASCRIZIONE IMMAGINI ‚Äî Philips Serie 7000\n');

        const { readdirSync, existsSync, writeFileSync, mkdirSync, readFileSync } = await import('fs');
        const { basename } = await import('path');

        // ‚îÄ‚îÄ Indice di tracciamento: ricorda le immagini gi√† processate ‚îÄ‚îÄ
        const dataDir = resolve(process.cwd(), 'data');
        if (!existsSync(dataDir)) mkdirSync(dataDir, { recursive: true });
        const indexPath = resolve(dataDir, 'image-process-index.json');
        let processedIndex = {};
        try {
            if (existsSync(indexPath)) {
                processedIndex = JSON.parse(readFileSync(indexPath, 'utf-8'));
            }
        } catch { processedIndex = {}; }

        const saveIndex = () => {
            writeFileSync(indexPath, JSON.stringify(processedIndex, null, 2), 'utf-8');
        };

        let allImages = [];
        for (const dir of pdfDirs) {
            try {
                if (existsSync(dir)) {
                    const files = readdirSync(dir).filter(f => f.toLowerCase().endsWith('.png')).map(f => resolve(dir, f));
                    allImages.push(...files);
                }
            } catch (e) {
                console.log(`‚ö†Ô∏è Cartella non trovata o inaccessibile: ${dir}`);
            }
        }

        allImages.sort();
        if (allImages.length === 0) {
            console.log('‚ùå Nessuna immagine trovata nelle cartelle specificate.');
            process.exit(1);
        }

        // Filtra immagini gi√† processate
        const pendingImages = allImages.filter(img => !processedIndex[basename(img)]);
        const alreadyDone = allImages.length - pendingImages.length;

        console.log(`Trovate ${allImages.length} immagini totali nelle cartelle Philips.`);
        if (alreadyDone > 0) {
            console.log(`‚úÖ ${alreadyDone} gi√† processate (skip). Rimangono ${pendingImages.length} da processare.`);
        }

        if (pendingImages.length === 0) {
            console.log('\nüéâ Tutte le immagini sono gi√† state processate!\n');
            process.exit(0);
        }

        const { extractRecipesFromImages } = await import('./src/enhancer.js');
        const { findAndDownloadImage } = await import('./src/image-finder.js');

        const BATCH_SIZE = 1; // 1 immagine per volta per garantire output completi
        let totalExtracted = 0;

        for (let i = 0; i < pendingImages.length; i += BATCH_SIZE) {
            const batch = pendingImages.slice(i, i + BATCH_SIZE);
            const currentBatchNum = Math.floor(i / BATCH_SIZE) + 1;
            const totalBatches = Math.ceil(pendingImages.length / BATCH_SIZE);
            console.log(`\nüì¶ Processo batch ${currentBatchNum} di ${totalBatches} (${batch.length} immagini)...`);
            console.log(`   üìÑ ${basename(batch[0])}`);

            try {
                const recipes = await extractRecipesFromImages(batch);
                if (recipes && recipes.length > 0) {
                    console.log(`   ‚úÖ Trovate ${recipes.length} ricette in questo batch.`);
                    for (const recipe of recipes) {
                        totalExtracted++;
                        recipe.slug = recipe.slug || recipe.title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                        if (!recipe.category) recipe.category = 'Pasta';

                        const outputDir = resolve(ricettarioPath, 'ricette', 'pasta');
                        if (!existsSync(outputDir)) {
                            mkdirSync(outputDir, { recursive: true });
                        }

                        // Stock Image Search
                        if (args['no-image'] !== true) {
                            try {
                                const imageData = await findAndDownloadImage(recipe, ricettarioPath);
                                if (imageData) {
                                    recipe.image = imageData.homeRelativePath;
                                    recipe.imageAttribution = imageData.attribution;
                                }
                            } catch (err) {
                                console.log(`   ‚ö†Ô∏è Immagine per ${recipe.title} non trovata (${err.message}).`);
                            }
                        }

                        const outputHtml = generateHtml(recipe);
                        const outputFile = resolve(outputDir, `${recipe.slug}.html`);
                        writeFileSync(outputFile, outputHtml, 'utf-8');

                        if (args['no-inject'] !== true) {
                            try {
                                injectCard(recipe, ricettarioPath);
                            } catch (err) {
                                console.log(`   ‚ö†Ô∏è Errore inject homepage card per ${recipe.title}.`);
                            }
                        }

                        console.log(`   üíæ Salvata: ${recipe.title} -> ricette/pasta/${recipe.slug}.html`);
                    }
                } else {
                    console.log(`   ‚è≠Ô∏è Nessuna ricetta trovata in questo batch.`);
                }

                // Registra immagine come processata nell'indice
                for (const img of batch) {
                    processedIndex[basename(img)] = {
                        processedAt: new Date().toISOString(),
                        recipesFound: recipes?.length || 0
                    };
                }
                saveIndex();

            } catch (err) {
                console.error(`‚ùå Errore durante estrazione/check ricetta "${batch[0]}":`, err.message);
                // Registra comunque come processata per evitare loop infiniti su errori
                for (const img of batch) {
                    processedIndex[basename(img)] = {
                        processedAt: new Date().toISOString(),
                        error: err.message
                    };
                }
                saveIndex();
            }

            if (i + BATCH_SIZE < pendingImages.length) {
                console.log("   ‚è≥ Attesa per rate limit API (1s)...");
                await new Promise(r => setTimeout(r, 1000));
            }
        }

        console.log(`\nüéâ TRASCRIZIONE COMPLETATA! ESTRATTE E SALVATE ${totalExtracted} RICETTE TOTALI.\n`);
        process.exit(0);
    }


    // ‚îÄ‚îÄ Mode C: Discovery ‚Äî cerca e genera ‚îÄ‚îÄ
    if (args.scopri) {
        const numResults = parseInt(args.quante) || 5;
        const results = await discoverRecipes(args.scopri, numResults);

        if (results.length === 0) process.exit(0);

        const choice = await askUser('üëâ Quale vuoi generare? (numero, o "tutti", o "esci"): ');

        if (choice.toLowerCase() === 'esci' || choice === 'q') {
            console.log('\nüëã Alla prossima!');
            process.exit(0);
        }

        let urlsToProcess = [];

        if (choice.toLowerCase() === 'tutti') {
            urlsToProcess = results.map(r => r.url);
        } else {
            // Supporta singolo numero o lista separata da virgola: "1,3,5"
            const indices = choice.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
            urlsToProcess = indices
                .map(i => results.find(r => r.index === i)?.url)
                .filter(Boolean);
        }

        if (urlsToProcess.length === 0) {
            console.log('‚ùå Nessuna selezione valida.');
            process.exit(1);
        }

        console.log(`\nüöÄ Genero ${urlsToProcess.length} ricett${urlsToProcess.length === 1 ? 'a' : 'e'}...\n`);

        for (const url of urlsToProcess) {
            console.log(`\n${'‚îÄ'.repeat(50)}`);
            console.log(`üîó ${url}`);
            console.log(`${'‚îÄ'.repeat(50)}`);
            try {
                // Reusa il flusso URL standard
                args.url = url;
                await processRecipe(args);
            } catch (err) {
                console.error(`‚ö†Ô∏è  Errore: ${err.message}. Passo alla prossima.`);
            }
        }

        process.exit(0);
    }

    // ‚îÄ‚îÄ Mode A/B: URL o generazione da zero ‚îÄ‚îÄ
    await processRecipe(args);
}

/**
 * Processa una singola ricetta (da URL o da zero)
 */
async function processRecipe(args) {
    let enhancedRecipe;

    if (args.url) {
        // Mode A: Scraping + Enhancement
        const rawData = await scrapeRecipe(args.url);
        console.log(`üìã Estratti: ${rawData.ingredients.length} ingredienti, ${rawData.steps.length} step\n`);
        enhancedRecipe = await enhanceRecipe(rawData);
    } else {
        // Mode B: Generazione da zero
        enhancedRecipe = await generateRecipe(args.nome, {
            idratazione: args.idratazione,
            tipo: args.tipo,
            note: args.note,
        });
    }

    // Genera HTML
    const html = generateHtml(enhancedRecipe);
    const slug = enhancedRecipe.slug || args.nome?.toLowerCase().replace(/\s+/g, '-') || 'nuova-ricetta';
    enhancedRecipe.slug = slug;

    // Determina output path con sottocartella per categoria
    const ricettarioPath = resolve(process.cwd(), args.output || process.env.RICETTARIO_PATH || '../Ricettario');
    const category = enhancedRecipe.category || args.tipo || 'Pane';
    const categoryFolder = {
        Pane: 'pane', Pizza: 'pizza', Pasta: 'pasta',
        Lievitati: 'lievitati', Focaccia: 'focaccia',
    };
    const subfolder = categoryFolder[category] || category.toLowerCase();
    const outputDir = resolve(ricettarioPath, 'ricette', subfolder);
    const outputFile = resolve(outputDir, `${slug}.html`);

    // Assicurati che la cartella esista
    if (!existsSync(outputDir)) {
        mkdirSync(outputDir, { recursive: true });
    }

    // Step 4: Cerca e scarica immagine Wikimedia
    if (args['no-image'] !== true) {
        const imageData = await findAndDownloadImage(enhancedRecipe, ricettarioPath);
        if (imageData) {
            enhancedRecipe.image = imageData.homeRelativePath;
            enhancedRecipe.imageAttribution = imageData.attribution;
            enhancedRecipe._imageData = imageData;
        }
    }

    // Step 5: Salva il file HTML (rigenera con immagine)
    const finalHtml = generateHtml(enhancedRecipe);
    writeFileSync(outputFile, finalHtml, 'utf-8');

    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('   üìÑ RICETTA GENERATA');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log(`üìù Titolo: ${enhancedRecipe.title}`);
    console.log(`üíß Idratazione: ${enhancedRecipe.hydration}%`);
    console.log(`üå°Ô∏è Temp target: ${enhancedRecipe.targetTemp}`);
    console.log(`üõí Ingredienti: ${enhancedRecipe.ingredients.length}`);
    console.log(`‚öôÔ∏è Step spirale: ${enhancedRecipe.stepsSpiral.length}`);
    console.log(`ü§≤ Step a mano: ${enhancedRecipe.stepsHand.length}`);
    if (enhancedRecipe.image) {
        console.log(`üì∏ Immagine: ${enhancedRecipe.image}`);
    }
    console.log(`üìÑ File: ${outputFile}`);

    // Step 6: Inserisci la card nella homepage
    if (args['no-inject'] !== true) {
        console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('   üè† INTEGRAZIONE HOMEPAGE');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        try {
            injectCard(enhancedRecipe, ricettarioPath);
        } catch (err) {
            console.error(`‚ö†Ô∏è  Errore nell'inserimento card: ${err.message}`);
            console.log('La pagina ricetta √® stata creata comunque.');
        }
    }

    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('   ‚úÖ COMPLETATO');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log(`\nüëâ Prossimi passi:`);
    console.log(`   1. Apri http://localhost:5173 e verifica il risultato`);
    console.log(`   2. git add + commit + push\n`);
}


main().catch(err => {
    console.error('\n‚ùå Errore:', err.message);
    process.exit(1);
});
